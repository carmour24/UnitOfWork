package com.opidis.ca.data

import java.util.concurrent.CompletableFuture
import java.util.concurrent.CompletionStage

//val jooqEntityTrackingUnitOfWork = EntityTrackingUnitOfWork(EntityQueryMappingConfiguration(DSL.using("")), JooqQueryCoordinator
//(DSL.using("")))


/**
 * Unit of Work implementation for tracking changes within [Entity] subclasses which delegates query generation and
 * execution to [queryConfiguration] and [queryCoordinator] respectively.
 *
 * Unit of Work keeps track of changes made to entities within the scope of, for example, a single HTTP POST
 * or GraphQL mutation. Changes are tracked via the various track* functions. These update internal lists of changes.
 * Changes are batched and call sites for the track methods can be notified via returned [CompletionStage] objects.
 *
 * @param TQuery type of Query which is generated by [queryConfiguration] from tracked entity changes. These queries
 * are executed by the [queryCoordinator].
 *
 */
class EntityTrackingUnitOfWork<TQuery>(
        private val queryConfiguration: QueryMappingConfiguration<TQuery>,
        private val queryCoordinator: QueryCoordinator<TQuery>
) : UnitOfWork<Entity> {

    private val newEntities = mutableListOf<EntityChangeWrapper>()
    private val changedEntities = mutableListOf<EntityChangeWrapper>()
    private val deletedEntities = mutableListOf<EntityChangeWrapper>()

    private fun trackEntity(tracked: Entity, trackingList: MutableList<EntityChangeWrapper>): CompletionStage<Int> {
        val entityChangeWrapper = EntityChangeWrapper(tracked)
        trackingList += entityChangeWrapper

        // TODO: Add error handling when the throwable, u, is not null.
        entityChangeWrapper.completionStage.whenComplete { _, u -> trackingList.remove(entityChangeWrapper) }

        return entityChangeWrapper.completionStage
    }

    override fun trackNew(tracked: Entity): CompletionStage<Int> {
        return trackEntity(tracked, newEntities)
    }

    override fun trackDelete(tracked: Entity): CompletionStage<Int> {
        return trackEntity(tracked, deletedEntities)
    }

    override fun trackChange(tracked: Entity): CompletionStage<Int> {
        return trackEntity(tracked, changedEntities)
    }

    override fun complete() {
        queryCoordinator.transaction {
            // Group all entities by their type so we can batch their updates by type
            // We may be able to get away with just batching all updates in one single batch regardless of type,
            // need to test
            newEntities.groupBy { it.javaClass }
                    // For each entity type create a batch of queries and execute.
                    .forEach {
                        queryCoordinator.batch(
                                it.value.map {
                                    queryConfiguration.queryFor(
                                            changeType = ChangeType.Insert,
                                            entity = it.trackedEntity
                                    )
                                }
                        )
                                .forEachIndexed { index, affectedCount ->
                                    // Take each result from the batch update/insert/delete and complete the
                                    // associated EntityChangeWrapper which will use its completion stage to
                                    // notify any interested parties, e.g. to ensure an update was performed.
                                    newEntities[index].complete(affectedCount)
                                }
                    }
        }
    }

    private class EntityChangeWrapper(val trackedEntity: Entity) {
        private val completableFuture = CompletableFuture<Int>()
        val completionStage: CompletionStage<Int> = completableFuture.minimalCompletionStage()

        fun complete(affectedCount: Int) {
            completableFuture.complete(affectedCount)
        }
    }
}

package com.opidis.unitofwork.data

import java.util.concurrent.CompletableFuture
import java.util.concurrent.CompletableFuture.allOf
import java.util.concurrent.CompletionStage

/**
 * Type alias of UnitOfWork for tracking [Entity] subtypes. This is a convenience to be used in other
 * classes supporting tracking [Entity] changes and persisting those.
 */
typealias EntityTrackingUnitOfWork = UnitOfWork<Entity, ExecutionInfo>

/**
 * Default Unit of Work implementation for tracking changes within [Entity] subclasses which delegates query generation
 * and
 * execution to [queryConfiguration] and [queryCoordinator] respectively.
 *
 * Unit of Work keeps track of changes made to entities within the scope of, for example, a single HTTP POST
 * or GraphQL mutation. Changes are tracked via the various tracker functions ([trackChange], [trackDelete], [trackNew]).
 * These update internal lists of changes. * Changes are batched and call sites for the track methods can be notified
 * via returned [CompletionStage] objects.
 *
 * TODO: Consider combining [QueryMappingConfiguration] and [QueryCoordinator] interfaces to remove the [TQuery] param
 *
 *
 * @param TQuery type of Query which is generated by [queryConfiguration] from tracked entity changes. These queries
 * are executed by the [queryCoordinator].
 *
 */
open class DefaultEntityTrackingUnitOfWork<TQuery, TExecutionInfo : ExecutionInfo>(
        private val queryConfiguration: QueryMappingConfiguration<TQuery>,
        private val queryCoordinator: QueryCoordinator<TQuery, TExecutionInfo>
) : UnitOfWork<Entity, TExecutionInfo> {

    private val newEntities = mutableListOf<EntityChangeWrapper>()
    private val changedEntities = mutableListOf<EntityChangeWrapper>()
    private val deletedEntities = mutableListOf<EntityChangeWrapper>()

    private fun trackEntity(tracked: Entity, trackingList: MutableList<EntityChangeWrapper>): CompletionStage<Int> {
        val entityChangeWrapper = EntityChangeWrapper(tracked)
        trackingList += entityChangeWrapper

        // TODO: Add error handling when the throwable, u, is not null.
        entityChangeWrapper.completionStage.whenComplete { _, u -> trackingList.remove(entityChangeWrapper) }

        return entityChangeWrapper.completionStage
    }

    override fun trackNew(tracked: Entity): CompletionStage<Int> {
        return trackEntity(tracked, newEntities)
    }

    override fun trackDelete(tracked: Entity): CompletionStage<Int> {
        return trackEntity(tracked, deletedEntities)
    }

    override fun trackChange(tracked: Entity): CompletionStage<Int> {
        return trackEntity(tracked, changedEntities)
    }

    override fun complete(executionInfo: TExecutionInfo?): CompletionStage<Void> {
        // TODO: Need to add error handling to this function. Should probably be done in a subclass although maybe
        // providing a query error handling strategy would be more flexible. Having said that, maybe in the
        // coordinator or query mapping is more natural.
        // TODO: Create queries first to reduce time spent in transaction
        queryCoordinator.transaction {
            // Group all entities by their type so we can batchExecute their updates by type
            mapOf(
                    (newEntities to ChangeType.Insert),
                    (changedEntities to ChangeType.Update),
                    (deletedEntities to ChangeType.Delete)
            ).forEach { entityChangeMap ->
                val entityListForChangeType = entityChangeMap.component1()
                val changeType = entityChangeMap.component2()

                entityListForChangeType.groupBy { it.javaClass }
                        // For each entity type create a batchExecute of queries and execute.
                        .forEach {
                            queryCoordinator.batchExecute(
                                    it.value.map {
                                        queryConfiguration.queryFor(
                                                changeType = changeType,
                                                entities = listOf(it.trackedEntity)
                                        )
                                    },
                                    executionInfo).thenAccept {
                                it.forEachIndexed { index, affectedCount ->
                                    // Take each result from the batchExecute update/insert/delete and complete the
                                    // associated EntityChangeWrapper which will use its completion stage to
                                    // notify any interested parties, e.g. to ensure an update was performed.
                                    entityListForChangeType[index].complete(affectedCount)
                                }
                            }
                        }

            }

        }

        val all = newEntities + changedEntities + deletedEntities

        return allOf(*all.map { it.completionStage.toCompletableFuture() }.toTypedArray())
    }

    /**
     * Internal class for holding combinations of [CompletableFuture] and [Entity]
     *
     * [trackedEntity] changes are tracked by storing instances of this class in an appropriate collection. Upon
     * persisting these changes the [completableFuture] instance is completed with the update count to allow the call
     * site for tracking to be notified of the success or otherwise of the persistence attempt through the
     * resulting [CompletionStage] produced from [completableFuture] and exposed publicly as [completionStage].
     */
    private class EntityChangeWrapper(val trackedEntity: Entity) {
        private val completableFuture = CompletableFuture<Int>()
        val completionStage: CompletionStage<Int> = completableFuture.minimalCompletionStage()

        fun complete(affectedCount: Int) {
            completableFuture.complete(affectedCount)
        }
    }
}